<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Lato:300,300italic,400,400italic,700,700italic|Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-big-counter.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"2738132159.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="这一章学完，我们仍然不能写自己的代码。直到第三章学完才能够写基础代码。当然超前学习是可以开始代码书写的。 所以我们前两篇笔记还是以背为主，或则是用Typora打开大纲模式，就可以很好地阅读Markdown文档。">
<meta property="og:type" content="article">
<meta property="og:title" content="汇编语言（二）">
<meta property="og:url" content="https://2738132159.github.io/2021/05/20/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%883%EF%BC%89/index.html">
<meta property="og:site_name" content="小柜员">
<meta property="og:description" content="这一章学完，我们仍然不能写自己的代码。直到第三章学完才能够写基础代码。当然超前学习是可以开始代码书写的。 所以我们前两篇笔记还是以背为主，或则是用Typora打开大纲模式，就可以很好地阅读Markdown文档。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://2738132159.github.io/2021/05/20/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%883%EF%BC%89/%E8%AE%A1%E7%AE%97%E5%99%A8.png">
<meta property="og:image" content="https://2738132159.github.io/2021/05/20/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%883%EF%BC%89/%E6%AE%B5%E9%94%99%E8%AF%AF.png">
<meta property="og:image" content="https://2738132159.github.io/2021/05/20/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%883%EF%BC%89/%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8.png">
<meta property="article:published_time" content="2021-05-20T12:14:17.000Z">
<meta property="article:modified_time" content="2021-05-20T12:21:04.130Z">
<meta property="article:author" content="康慧春">
<meta property="article:tag" content="考试笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://2738132159.github.io/2021/05/20/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%883%EF%BC%89/%E8%AE%A1%E7%AE%97%E5%99%A8.png">

<link rel="canonical" href="https://2738132159.github.io/2021/05/20/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%883%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>汇编语言（二） | 小柜员</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
<a target="_blank" rel="noopener" href="https://github.com/2738132159" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">小柜员</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://2738132159.github.io/2021/05/20/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%883%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/aaa.gif">
      <meta itemprop="name" content="康慧春">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小柜员">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          汇编语言（二）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-20 20:14:17 / 修改时间：20:21:04" itemprop="dateCreated datePublished" datetime="2021-05-20T20:14:17+08:00">2021-05-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B1%87%E7%BC%96/" itemprop="url" rel="index"><span itemprop="name">汇编</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="热度" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">热度：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/05/20/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%883%EF%BC%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/05/20/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%883%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>这一章学完，我们仍然不能写自己的代码。直到第三章学完才能够写基础代码。当然超前学习是可以开始代码书写的。</p>
<p>所以我们前两篇笔记还是以背为主，或则是用<strong>Typora</strong>打开大纲模式，就可以很好地阅读Markdown文档。</p>
<span id="more"></span>

<p>如果你是windows系统，那么在一些你无法计算的数字的时候使用系统自带的计算机切换到程序员模式。</p>
<p><img src="%E8%AE%A1%E7%AE%97%E5%99%A8.png"></p>
<h2 id="数据传送类指令"><a href="#数据传送类指令" class="headerlink" title="数据传送类指令"></a>数据传送类指令</h2><h3 id="通用数据传送指令"><a href="#通用数据传送指令" class="headerlink" title="通用数据传送指令"></a>通用数据传送指令</h3><h4 id="传送指令MOV"><a href="#传送指令MOV" class="headerlink" title="传送指令MOV"></a>传送指令MOV</h4><p>将src的值赋值给dest。</p>
<h5 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov dest,src	;dest&lt;-src</span><br></pre></td></tr></table></figure>

<h5 id="合法操作"><a href="#合法操作" class="headerlink" title="合法操作"></a>合法操作</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov reg&#x2F;mem,imm</span><br><span class="line">mov reg&#x2F;mem&#x2F;seg,reg</span><br><span class="line">mov reg&#x2F;seg,mem</span><br></pre></td></tr></table></figure>

<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov al,4				;al&lt;-4，字节传送</span><br><span class="line">mov cx,0ffh 			;cx&lt;-00ffh，字传送</span><br><span class="line">mov byte ptr[si],0ah	;ds:[si]&lt;-0ah,byte ptr说明是字节传送</span><br><span class="line">mov word ptr[si+2],0bh	;ds:[si+2]&lt;-0bh,word ptr说明是字传送</span><br><span class="line">mov ax,bx				;ax&lt;-bx</span><br><span class="line">mov [bx],al				;ds:[bx]&lt;-al</span><br><span class="line">mov es,[si]				;es&lt;-ds:[si]</span><br><span class="line">mov cs,[si]				;非法指令！！如果直接修改CS会引起CPU执行的指令出错。</span><br><span class="line">mov ds,es				;非法指令！！不能从seg到seg</span><br></pre></td></tr></table></figure>



<h4 id="交换指令XCHG"><a href="#交换指令XCHG" class="headerlink" title="交换指令XCHG"></a>交换指令XCHG</h4><p>交换两者的值。</p>
<h5 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xchg	reg,reg&#x2F;mem		;reg&lt;--&gt;reg&#x2F;mem</span><br></pre></td></tr></table></figure>

<h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1234h	;ax&#x3D;1234h</span><br><span class="line">mov bx,5678h	;bx&#x3D;5678h</span><br><span class="line">xchg ax,bx		;ax&#x3D;5678h,bx&#x3D;1234h</span><br><span class="line">xchg ah,al		;ax&#x3D;7856h</span><br></pre></td></tr></table></figure>



<h4 id="换码指令XLAT"><a href="#换码指令XLAT" class="headerlink" title="换码指令XLAT"></a>换码指令XLAT</h4><p>类似于C语言中的打表。将其代换为表中的元素值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">b = a[b];</span><br></pre></td></tr></table></figure>

<h5 id="基本语法-2"><a href="#基本语法-2" class="headerlink" title="基本语法"></a>基本语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xlat		;al&lt;-ds:[bx+al]</span><br><span class="line">xlat label	;这里的label无意义</span><br></pre></td></tr></table></figure>

<h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov bx,100h</span><br><span class="line">mov al,03h</span><br><span class="line">xlat</span><br></pre></td></tr></table></figure>

<p>这里就是将数据段DS中，偏移BX+AL的数据，赋值给AL。</p>
<h3 id="堆栈操作指令"><a href="#堆栈操作指令" class="headerlink" title="堆栈操作指令"></a>堆栈操作指令</h3><h4 id="入栈指令PUSH"><a href="#入栈指令PUSH" class="headerlink" title="入栈指令PUSH"></a>入栈指令PUSH</h4><p>入栈会使SP减2，也就是进行16位数的操作。低地址存放于低地址，高地址存放于高地址。</p>
<h5 id="基本语法-3"><a href="#基本语法-3" class="headerlink" title="基本语法"></a>基本语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push r16&#x2F;m16&#x2F;seg	;r16:16位的寄存器，m16：16位的存储器单元。</span><br><span class="line">					;sp&lt;-sp-2, ss:[sp]&lt;-r16&#x2F;m16&#x2F;seg</span><br></pre></td></tr></table></figure>

<h5 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,7812h</span><br><span class="line">push ax			;ax入栈</span><br><span class="line">push [2000h]	;ds:[2000h]的一个字（2字节）入栈</span><br></pre></td></tr></table></figure>



<h4 id="出栈指令POP"><a href="#出栈指令POP" class="headerlink" title="出栈指令POP"></a>出栈指令POP</h4><p>出栈会使SP加2，也就是进行16位数的操作。低地址送低地址，高地址送高地址。</p>
<h5 id="基本语法-4"><a href="#基本语法-4" class="headerlink" title="基本语法"></a>基本语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop r16&#x2F;m16&#x2F;seg		;r16:16位的寄存器，m16：16位的存储器单元。</span><br><span class="line">					;sp&lt;-sp-2, ss:[sp]&lt;-r16&#x2F;m16&#x2F;seg</span><br></pre></td></tr></table></figure>

<h5 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop ax,7812h</span><br><span class="line">pop ax			;出栈一个16位数，并存到ax</span><br><span class="line">pop [2000h]		;出栈一个16位数，并存到ds:[2000h]</span><br></pre></td></tr></table></figure>



<h4 id="堆栈的应用"><a href="#堆栈的应用" class="headerlink" title="堆栈的应用"></a>堆栈的应用</h4><p>现在只需要有一个大概的堆栈概念就行了。例如子程序的调用，多次运算储存状态标志等都是可以用堆栈来记录当前程序的运行状态。以便于后续恢复运行。</p>
<h3 id="标志传送指令"><a href="#标志传送指令" class="headerlink" title="标志传送指令"></a>标志传送指令</h3><h4 id="标志寄存器传送"><a href="#标志寄存器传送" class="headerlink" title="标志寄存器传送"></a>标志寄存器传送</h4><h5 id="标志寄存器传入AH指令LAHF"><a href="#标志寄存器传入AH指令LAHF" class="headerlink" title="标志寄存器传入AH指令LAHF"></a>标志寄存器传入AH指令LAHF</h5><p>将FLAGS寄存器的低字节传到AX的高字节AH中。即状态标志位SF/ZF/AF/PF/CF对应送入AH。</p>
<h6 id="基本语法-5"><a href="#基本语法-5" class="headerlink" title="基本语法"></a>基本语法</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lahf</span><br></pre></td></tr></table></figure>



<h5 id="AH传入标志寄存器指令SAHF"><a href="#AH传入标志寄存器指令SAHF" class="headerlink" title="AH传入标志寄存器指令SAHF"></a>AH传入标志寄存器指令SAHF</h5><p>将AH传送到FLAGS的低字节中。与LAHF互为逆操作。</p>
<h6 id="基本语法-6"><a href="#基本语法-6" class="headerlink" title="基本语法"></a>基本语法</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sahf</span><br></pre></td></tr></table></figure>



<h5 id="标志寄存器入栈指令PUSHF"><a href="#标志寄存器入栈指令PUSHF" class="headerlink" title="标志寄存器入栈指令PUSHF"></a>标志寄存器入栈指令PUSHF</h5><p>上面的两条指令仅仅能够操作FLAGS的低字节，如果想要全部操作，则可以通过入栈指令PUSHF来实现。该指令会讲FLAGS16位一起压入栈顶，同时SP减2。</p>
<h6 id="基本语法-7"><a href="#基本语法-7" class="headerlink" title="基本语法"></a>基本语法</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pushf</span><br></pre></td></tr></table></figure>



<h5 id="标志寄存器出栈指令POPF"><a href="#标志寄存器出栈指令POPF" class="headerlink" title="标志寄存器出栈指令POPF"></a>标志寄存器出栈指令POPF</h5><p>同理，有入栈就有出栈，将栈顶元素放入FLAGS并且SP加2。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">popf</span><br></pre></td></tr></table></figure>



<h4 id="标志位操作"><a href="#标志位操作" class="headerlink" title="标志位操作"></a>标志位操作</h4><p>标志位操作指令可以操作CF、DF和IF三个标志位，而不影响其他标志位。其他标志位的改变必须借用上述四条指令来间接实现。</p>
<h6 id="基本语法-8"><a href="#基本语法-8" class="headerlink" title="基本语法"></a>基本语法</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">clc		;CF&lt;-0</span><br><span class="line">stc		;CF&lt;-1</span><br><span class="line">cmc		;CF求反</span><br><span class="line">cld		;DF&lt;-0</span><br><span class="line">std		;DF&lt;-1</span><br><span class="line">cli		;IF&lt;-0</span><br><span class="line">sti		;IF&lt;-1</span><br></pre></td></tr></table></figure>

<p>其实这个6个十分好记，修改为0 ，就是cl+标志位首字母，修改为1，就是st+标志位首字母。</p>
<h3 id="地址传送指令"><a href="#地址传送指令" class="headerlink" title="地址传送指令"></a>地址传送指令</h3><h4 id="有效地址传送指令LEA"><a href="#有效地址传送指令LEA" class="headerlink" title="有效地址传送指令LEA"></a>有效地址传送指令LEA</h4><p>将存储器操作数的有效地址传送至指定的寄存器。</p>
<h5 id="基本语法-9"><a href="#基本语法-9" class="headerlink" title="基本语法"></a>基本语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lea r16, mem</span><br></pre></td></tr></table></figure>

<h5 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov bx, 0400h</span><br><span class="line">mov si, 3ch</span><br><span class="line">lea bx, [bx+si+0f62h]	;bx&lt;-bx+si+0f62h&#x3D;0400h+3ch+0f62h&#x3D;139eh</span><br></pre></td></tr></table></figure>

<p>BX将会得到主存单元的有效地址，而不是物理地址，也不是该单元的内容。</p>
<h4 id="指针传送指令LES、LDS"><a href="#指针传送指令LES、LDS" class="headerlink" title="指针传送指令LES、LDS"></a>指针传送指令LES、LDS</h4><p>LDS与LES指令将主存中MEM指定的字送至R16，并将MEM的下一字送DS或ES寄存器。</p>
<h5 id="基本语法-10"><a href="#基本语法-10" class="headerlink" title="基本语法"></a>基本语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lds r16, mem	;r16&lt;-mem, ds&lt;-mem+2</span><br><span class="line">les r16, mem	;r16&lt;-mem, es&lt;-mem+2</span><br></pre></td></tr></table></figure>

<h5 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov word ptr [3060h], 0100h		;在3060h写入0100h</span><br><span class="line">mov word ptr [3062h], 1450h		;在3062h写入1450h</span><br><span class="line">lds si, [3060h]		;ds&#x3D;1450h, si&#x3D;0100h	(仔细看赋值，这条指令还是比较好理解的)</span><br><span class="line">les di, [3060h]		;es&#x3D;1450h, di&#x3D;0100h</span><br></pre></td></tr></table></figure>



<h2 id="算数运算类指令"><a href="#算数运算类指令" class="headerlink" title="算数运算类指令"></a>算数运算类指令</h2><p>看这部分之前最好去看看笔记一的标志寄存器</p>
<p>我们按照MOV指令习惯，这部分将<strong>第一个叫做目的操作数，第二个叫做源操作数</strong></p>
<h3 id="加法指令"><a href="#加法指令" class="headerlink" title="加法指令"></a>加法指令</h3><h4 id="加法指令ADD"><a href="#加法指令ADD" class="headerlink" title="加法指令ADD"></a>加法指令ADD</h4><p>将两个操作数的值相加，结果存入目的操作数。</p>
<h5 id="基本语法-11"><a href="#基本语法-11" class="headerlink" title="基本语法"></a>基本语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add reg, imm&#x2F;reg&#x2F;mem		;reg&lt;-reg+imm&#x2F;reg&#x2F;mem</span><br><span class="line">add mem, imm&#x2F;reg			;mem&lt;-mem+imm&#x2F;reg</span><br></pre></td></tr></table></figure>

<h5 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, 0f6h			;al&#x3D;0f6h</span><br><span class="line">add al, 07h				;al&#x3D;0f6h+07h&#x3D;102h，这里1溢出了，然后就是al&#x3D;02h</span><br></pre></td></tr></table></figure>



<h4 id="带进位加法指令ADC"><a href="#带进位加法指令ADC" class="headerlink" title="带进位加法指令ADC"></a>带进位加法指令ADC</h4><p>ADD除了完成ADD指令外还要加一个进位标志CF。</p>
<h5 id="基本语法-12"><a href="#基本语法-12" class="headerlink" title="基本语法"></a>基本语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adc reg, imm&#x2F;reg&#x2F;mem		;reg&lt;-reg+imm&#x2F;reg&#x2F;mem+cf</span><br><span class="line">adc mem, imm&#x2F;reg			;mem&lt;-mem+imm&#x2F;reg+cf</span><br></pre></td></tr></table></figure>

<h5 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 4652h				;ax&#x3D;4652h</span><br><span class="line">add ax, 0f0f0h				;ax&#x3D;3742h,产生进位CF&#x3D;1</span><br><span class="line">mov dx, 0234h				;dx&#x3D;0234h</span><br><span class="line">adc dx, 0f0f0h				;dx&#x3D;f324h+CF(1)&#x3D;f325h，同时清零CF，CF&#x3D;0</span><br></pre></td></tr></table></figure>

<p>可以看出也就是多加了一个CF而已。</p>
<h4 id="增量指令INC"><a href="#增量指令INC" class="headerlink" title="增量指令INC"></a>增量指令INC</h4><p>自增1，等同于C语言里面的++。<strong>自增不影响标志位</strong>。</p>
<h5 id="基本语法-13"><a href="#基本语法-13" class="headerlink" title="基本语法"></a>基本语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inc reg&#x2F;mem		;reg&#x2F;mem&lt;-reg&#x2F;mem+1</span><br></pre></td></tr></table></figure>

<h5 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov bx,0</span><br><span class="line">inc bx			;bx&#x3D;1</span><br></pre></td></tr></table></figure>



<h3 id="减法指令"><a href="#减法指令" class="headerlink" title="减法指令"></a>减法指令</h3><h4 id="减法指令SUB"><a href="#减法指令SUB" class="headerlink" title="减法指令SUB"></a>减法指令SUB</h4><p>目的操作数减去源操作数，结果存入目的操作书</p>
<h5 id="基本语法-14"><a href="#基本语法-14" class="headerlink" title="基本语法"></a>基本语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sub reg, imm&#x2F;reg&#x2F;mem		;reg&lt;-reg-imm&#x2F;reg&#x2F;mem</span><br><span class="line">sub mem, imm&#x2F;reg			;mem&lt;-mem-imm&#x2F;reg</span><br></pre></td></tr></table></figure>

<h5 id="示例-10"><a href="#示例-10" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, 0fbh				;al&#x3D;0fbh</span><br><span class="line">sub al, 07h					;al&#x3D;0f4h	CF&#x3D;0</span><br></pre></td></tr></table></figure>



<h4 id="带错位减法指令SBB"><a href="#带错位减法指令SBB" class="headerlink" title="带错位减法指令SBB"></a>带错位减法指令SBB</h4><p>同加法有进位，减法也有借位，这个在之前状态寄存器的时候就已经讲了。这条指令就会把借位减下去。</p>
<h5 id="基本语法-15"><a href="#基本语法-15" class="headerlink" title="基本语法"></a>基本语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sbb reg, imm&#x2F;reg&#x2F;mem		;reg&lt;-reg-imm&#x2F;reg&#x2F;mem-cf</span><br><span class="line">sbb mem, imm&#x2F;reg			;mem&lt;-mem-imm&#x2F;reg-cf</span><br></pre></td></tr></table></figure>

<h5 id="示例-11"><a href="#示例-11" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 4652h				;ax&#x3D;4652h</span><br><span class="line">sub ax, 0f0f0h				;ax&#x3D;5562h(这里溢出了，本来减下来应该是负数), of&#x3D;0, sf&#x3D;0,zf&#x3D;0, af&#x3D;0, pf&#x3D;0, cf&#x3D;1</span><br><span class="line">mov dx, 0234h				;dx&#x3D;0234h</span><br><span class="line">sbb dx, 0f0f0h				;dx&#x3D;1143h(这里溢出了，本来减下来应该是负数), of&#x3D;0, sf&#x3D;0,zf&#x3D;0, af&#x3D;0, pf&#x3D;0, cf&#x3D;1</span><br><span class="line">							;原本234h-f0f0h &#x3D; 1144h。然后1144h - CF &#x3D; 1143h</span><br></pre></td></tr></table></figure>



<h4 id="减量指令DEC"><a href="#减量指令DEC" class="headerlink" title="减量指令DEC"></a>减量指令DEC</h4><p>同自增，这个就是自减。<strong>自减不影响标志位</strong>。</p>
<h5 id="基本语法-16"><a href="#基本语法-16" class="headerlink" title="基本语法"></a>基本语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dec reg&#x2F;mem</span><br></pre></td></tr></table></figure>

<h5 id="示例-12"><a href="#示例-12" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dec cx</span><br></pre></td></tr></table></figure>



<h4 id="求补指令NEG"><a href="#求补指令NEG" class="headerlink" title="求补指令NEG"></a>求补指令NEG</h4><p>NEG指令也是一个单操作数指令。它的意思是，用零减去这个数，然后将结果存回去。也就是求一个数的补码。<strong>NEG指令会影响状态位</strong>。</p>
<h5 id="基本语法-17"><a href="#基本语法-17" class="headerlink" title="基本语法"></a>基本语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">neg reg&#x2F;mem					;reg&#x2F;mem&lt;-0-reg&#x2F;mem</span><br></pre></td></tr></table></figure>

<h5 id="示例-13"><a href="#示例-13" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 0ff64h</span><br><span class="line">neg al						;ax&#x3D;ff9ch, of&#x3D;0, sf&#x3D;1,zf&#x3D;0, af&#x3D;0, pf&#x3D;1, cf&#x3D;1</span><br></pre></td></tr></table></figure>



<h4 id="比较指令CMP"><a href="#比较指令CMP" class="headerlink" title="比较指令CMP"></a>比较指令CMP</h4><p>将目的操作数减去源操作数，但是不会将结果存入源操作数，<strong>只会改变状态寄存器</strong>。</p>
<h5 id="基本语法-18"><a href="#基本语法-18" class="headerlink" title="基本语法"></a>基本语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmp reg, imm&#x2F;reg&#x2F;mem</span><br><span class="line">cmp mem, imm&#x2F;reg</span><br></pre></td></tr></table></figure>

<h5 id="示例-14"><a href="#示例-14" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmp al, 100			;al-100</span><br><span class="line">jb below			;al&lt;100，就跳转到below标记的地方。</span><br><span class="line">					;jb指令后面再讲，这里不讲他是什么意思。现在只需要可以用一些语句去判断标志位</span><br></pre></td></tr></table></figure>



<h3 id="乘法指令"><a href="#乘法指令" class="headerlink" title="乘法指令"></a>乘法指令</h3><h4 id="无符号数乘法指令MUL"><a href="#无符号数乘法指令MUL" class="headerlink" title="无符号数乘法指令MUL"></a>无符号数乘法指令MUL</h4><p>将操作数乘以al（8位）或则ax（16位），分别放到ax或则dx、ax。乘法指令会影响标志位。</p>
<p>8位的很好理解，但是16位乘以16位会得到一个32位的数字，这远远超过了16位寄存器ax能够表示的范围，所以只能将其中的高16位放到dx中，而低16位放到ax中。</p>
<h5 id="基本语法-19"><a href="#基本语法-19" class="headerlink" title="基本语法"></a>基本语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mul r8&#x2F;m8			;ax&lt;-al*r8&#x2F;m8</span><br><span class="line">mul r16&#x2F;m16			;dx,ax&lt;-ax*r16&#x2F;m16</span><br></pre></td></tr></table></figure>

<h5 id="示例-15"><a href="#示例-15" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al, 0b4h		;al&#x3D;b4h&#x3D;180d</span><br><span class="line">mov bl, 11h			;bl&#x3D;11h&#x3D;17d</span><br><span class="line">mul bl				;ax&#x3D;al*bl&#x3D;0bf4h&#x3D;3060d, of&#x3D;cf&#x3D;1</span><br></pre></td></tr></table></figure>



<h4 id="有符号数乘法指令IMUL"><a href="#有符号数乘法指令IMUL" class="headerlink" title="有符号数乘法指令IMUL"></a>有符号数乘法指令IMUL</h4><p>将操作数乘以al（8位）或则ax（16位），分别放到ax或则dx、ax。乘法指令会影响标志位。</p>
<p>8位的很好理解，但是16位乘以16位会得到一个32位的数字，这远远超过了16位寄存器ax能够表示的范围，所以只能将其中的高16位放到dx中，而低16位放到ax中。</p>
<p>与上面几乎一模一样，唯一的一点区别就是有符号。所有的数都会被当做有符号的数。</p>
<h5 id="基本语法-20"><a href="#基本语法-20" class="headerlink" title="基本语法"></a>基本语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">imul r8&#x2F;m8			;ax&lt;-al*r8&#x2F;m8</span><br><span class="line">imul r16&#x2F;m16		;dx,ax&lt;-ax*r16&#x2F;m16</span><br></pre></td></tr></table></figure>

<h5 id="示例-16"><a href="#示例-16" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al, 0b4h		;al&#x3D;b4h&#x3D;-76d (注意这里变成了负数，之前就讲过，二进制数到底表示什么要看程序员怎么用，而不是看这串数字！二进制数字本身没有意义)</span><br><span class="line">mov bl, 11h			;bl&#x3D;11h&#x3D;17d</span><br><span class="line">imul bl				;ax&#x3D;al*bl&#x3D;faf4h&#x3D;-1292cf&#x3D;1</span><br></pre></td></tr></table></figure>



<h3 id="除法指令"><a href="#除法指令" class="headerlink" title="除法指令"></a>除法指令</h3><h4 id="无符号数除法指令DIV"><a href="#无符号数除法指令DIV" class="headerlink" title="无符号数除法指令DIV"></a>无符号数除法指令DIV</h4><ol>
<li>将ax除以操作数，然后存放到al里面，ah放余数</li>
<li>将dx，ax除以操作数放到ax里面。dx放余数。</li>
</ol>
<p>除法指令对于标志位的影响没有定义！但是可能产生溢出，例如被除数远大于除数，所得到的商超过了表示范围（例如：ffffh / 1h， 放不到al里面去）。这个时候会产生一个<strong>编号为0的中断信号</strong>。</p>
<h5 id="基本语法-21"><a href="#基本语法-21" class="headerlink" title="基本语法"></a>基本语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div r8&#x2F;m8			;al&lt;-ax÷r8&#x2F;m8的商，ah&lt;-ax÷r8&#x2F;m8的余数</span><br><span class="line">div r16&#x2F;m16			;ax&lt;-dx,ax÷r16&#x2F;m16的商，dx&lt;-dx,ax÷r16&#x2F;m16的余数</span><br></pre></td></tr></table></figure>

<h5 id="示例-17"><a href="#示例-17" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 0400h		;al&#x3D;400h&#x3D;1024d</span><br><span class="line">mov bl, 0b4h		;bl&#x3D;b4h&#x3D;180d</span><br><span class="line">div bl				;al&#x3D;05h&#x3D;5d, ah&#x3D;7ch&#x3D;124d</span><br></pre></td></tr></table></figure>



<h4 id="有符号数除法指令IDIV"><a href="#有符号数除法指令IDIV" class="headerlink" title="有符号数除法指令IDIV"></a>有符号数除法指令IDIV</h4><p>同div，仅仅是把操作数看成有符号数而已。</p>
<h5 id="基本语法-22"><a href="#基本语法-22" class="headerlink" title="基本语法"></a>基本语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">idiv r8&#x2F;m8			;al&lt;-ax÷r8&#x2F;m8的商，ah&lt;-ax÷r8&#x2F;m8的余数</span><br><span class="line">idiv r16&#x2F;m16		;ax&lt;-dx,ax÷r16&#x2F;m16的商，dx&lt;-dx,ax÷r16&#x2F;m16的余数</span><br></pre></td></tr></table></figure>

<h5 id="示例-18"><a href="#示例-18" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 0400h		;al&#x3D;400h&#x3D;1024d</span><br><span class="line">mov bl, 0b4h		;bl&#x3D;b4h&#x3D;-76d</span><br><span class="line">idiv bl				;al&#x3D;f3h&#x3D;-13d, ah&#x3D;24h&#x3D;36d</span><br></pre></td></tr></table></figure>



<h3 id="符号扩展指令"><a href="#符号扩展指令" class="headerlink" title="符号扩展指令"></a>符号扩展指令</h3><p>在8086处理器中很多指令都要求两个操作数数据类型必须相同。比如bl是一个8位的数，ax是一个16位的数，这时候就没办法将他们直接相乘，所以必须做符号扩展。</p>
<ol>
<li><p>对于无符号的数，高位仅仅需要填0就可以了。上述的案例就将bh赋值为0，直接ax乘以bx就可以了。</p>
</li>
<li><p>对于有符号数，我们就没有办法直接填0，其本质上是填充为全部是1。关于为什么填充为1，可以看一下笔记一中对于补码的定义。但是这并不是很方便，所以8086提供了两条符号扩展指令CBW、CWD</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cbw			;将al有符号扩展到ah</span><br><span class="line">cwd			;将ax有符号扩展到dx，ax（为什么扩展到这两个寄存器，去看乘法和除法的定义）</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al, 80h ;al&#x3D;80h</span><br><span class="line">cbw			;ax&#x3D;ff80h</span><br><span class="line">add al, 255 ;al&#x3D;7fh</span><br><span class="line">cbw			;ax&#x3D;007fh</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="十进制调整指令"><a href="#十进制调整指令" class="headerlink" title="十进制调整指令"></a>十进制调整指令</h3><p>在我们实际显示的过程中，很明显我们要使用十进制来显示而非二进制。这里就会引入一个问题，我们如何将计算结果打印到屏幕上（这部分应该会在笔记三讲到）。你仅仅只需要知道有这样子一个问题就好了，这个指令就可以解决这个问题，到时候看到关于dos的操作的时候（输入输出），再回来看看十进制调整指令的两种指令就可以很好的理解为什么要这样子做了。当然指令的应用是灵活的，并不局限于解决某一类问题，某一类问题也不一定只有一个解决方法。毕竟8086的指令集并不是离散数学的最小完备集。</p>
<p>下面说说这两条指令究竟是做什么的。</p>
<h4 id="压缩BCD码调整指令"><a href="#压缩BCD码调整指令" class="headerlink" title="压缩BCD码调整指令"></a>压缩BCD码调整指令</h4><p>一个8位的al寄存器可以表示256个数字，具体是0—255或则-128—127看程序员的定义。这时候我们换一个表示方法，将al拆分成两个4位的寄存器。每个四位寄存器可以表示0—15，但是我们只使用0—9的部分，于是两个4位寄存器就可以表示一个最大为99的十进制数字！</p>
<p>daa指令是将以al为目的操作数的加法指令执行之后的结果，变为上述表示方法的十进制数字。</p>
<p>das同daa但是是减法指令。</p>
<p>所以在使用这两条指令之前都应该进行一个</p>
<h5 id="基本语法-23"><a href="#基本语法-23" class="headerlink" title="基本语法"></a>基本语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">daa		;调整以al为目的操作数的加法指令结果</span><br><span class="line">das		;调整以al为目的操作数的减法指令结果</span><br></pre></td></tr></table></figure>

<h5 id="示例-19"><a href="#示例-19" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov al, 68h</span><br><span class="line">mov bl, 28h</span><br><span class="line">add al, bl		;al&#x3D;90h(16进制的运算)</span><br><span class="line">daa				;al&#x3D;68+28&#x3D;96h(这个96就是以上述方式表示的)</span><br><span class="line"></span><br><span class="line">mov al, 68h</span><br><span class="line">mov bl, 28h</span><br><span class="line">sub al, bl		;al&#x3D;40h(16进制的运算)</span><br><span class="line">das				;al&#x3D;68-28&#x3D;40h(十进制的运算)</span><br></pre></td></tr></table></figure>

<h4 id="非压缩BCD码调整指令"><a href="#非压缩BCD码调整指令" class="headerlink" title="非压缩BCD码调整指令"></a>非压缩BCD码调整指令</h4><p>不同于上述的2位2进制数表示以为十进制数，这里用4位二进制数表示1位十进制数。</p>
<p><em>但是一定要切记aad指令用法与前面的不同，不要一股脑就下去了。</em></p>
<h5 id="基本语法-24"><a href="#基本语法-24" class="headerlink" title="基本语法"></a>基本语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aaa		;调整加法</span><br><span class="line">aas		;调整减法</span><br><span class="line">aam		;调整乘法</span><br><span class="line">aad		;调整除法</span><br></pre></td></tr></table></figure>

<h5 id="示例-20"><a href="#示例-20" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 0608h	;这里ax原本表示0608h，但是通过调整后，被认为是十进制的68</span><br><span class="line">mov bl, 09h		;这里同理为9</span><br><span class="line">add al, bl		;得到ax&#x3D;0611h</span><br><span class="line">aaa				;调整ax&#x3D;0707h</span><br><span class="line"></span><br><span class="line">mov ax, 0608h	;这里ax原本表示0608h，但是通过调整后，被认为是十进制的68</span><br><span class="line">mov bl, 09h		;这里同理为9</span><br><span class="line">sub al, bl		;得到ax&#x3D;06ffh</span><br><span class="line">aas				;调整ax&#x3D;0509h</span><br><span class="line"></span><br><span class="line">mov ax, 0608h	;这里ax原本表示0608h，但是通过调整后，被认为是十进制的68</span><br><span class="line">mov bl, 09h		;这里同理为9</span><br><span class="line">mul bl			;得到ax&#x3D;0048h</span><br><span class="line">aam				;调整ax&#x3D;0702h(8*9&#x3D;72,6被丢掉了)</span><br><span class="line"></span><br><span class="line">mov ax, 0608h	;这里ax原本表示0608h，但是通过调整后，被认为是十进制的68</span><br><span class="line">mov bl, 09h		;这里同理为9</span><br><span class="line">aad				;调整ax&#x3D;68&#x3D;0044h(这里是先调整)</span><br><span class="line">div bl			;得到al&#x3D;07h,ah&#x3D;05h</span><br></pre></td></tr></table></figure>



<h2 id="位操作类指令"><a href="#位操作类指令" class="headerlink" title="位操作类指令"></a>位操作类指令</h2><h3 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h3><p>影响标志位</p>
<h4 id="逻辑运算与指令AND"><a href="#逻辑运算与指令AND" class="headerlink" title="逻辑运算与指令AND"></a>逻辑运算与指令AND</h4><p>这没什么好说的了，学过C语言的都知道按位求与。从低位遍历到高位（二进制），如果相同位都为1则是1，其余则为0。</p>
<h5 id="基本语法-25"><a href="#基本语法-25" class="headerlink" title="基本语法"></a>基本语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">and reg, imm&#x2F;reg&#x2F;mem	;dest&lt;-dest &amp; src</span><br><span class="line">and mem, imm&#x2F;reg		;dest&lt;-dest &amp; src</span><br></pre></td></tr></table></figure>

<h5 id="示例-21"><a href="#示例-21" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al, 45h</span><br><span class="line">and al, 31h				;al&#x3D;01h</span><br><span class="line">and bl, 11110110b		;这条指令可以将bl的第0、3两位改为0</span><br></pre></td></tr></table></figure>



<h4 id="逻辑运算或指令OR"><a href="#逻辑运算或指令OR" class="headerlink" title="逻辑运算或指令OR"></a>逻辑运算或指令OR</h4><p>从低位遍历到高位（二进制），如果1位为1则是1，其余则为0。</p>
<h5 id="基本语法-26"><a href="#基本语法-26" class="headerlink" title="基本语法"></a>基本语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">or reg, imm&#x2F;reg&#x2F;mem	;dest&lt;-dest | src</span><br><span class="line">or mem, imm&#x2F;reg		;dest&lt;-dest | src</span><br></pre></td></tr></table></figure>

<h5 id="示例-22"><a href="#示例-22" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al, 45h</span><br><span class="line">or al, 31h				;al&#x3D;75h</span><br><span class="line">or bl, 00001001b		;这条指令可以将bl的第0、3两位改为1</span><br></pre></td></tr></table></figure>



<h4 id="逻辑运算异或指令XOR"><a href="#逻辑运算异或指令XOR" class="headerlink" title="逻辑运算异或指令XOR"></a>逻辑运算异或指令XOR</h4><p>从低位遍历到高位（二进制），如果不相同则为1，其余为0。</p>
<h5 id="基本语法-27"><a href="#基本语法-27" class="headerlink" title="基本语法"></a>基本语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xor reg, imm&#x2F;reg&#x2F;mem	;dest&lt;-dest ^ src</span><br><span class="line">xor mem, imm&#x2F;reg		;dest&lt;-dest ^ src</span><br></pre></td></tr></table></figure>

<h5 id="示例-23"><a href="#示例-23" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al, 45h</span><br><span class="line">xor al, 31h				;al&#x3D;74h</span><br><span class="line">xor bl, 00001001b		;这条指令可以将bl的第0、3两位求反(1变0,0变1)</span><br></pre></td></tr></table></figure>



<h4 id="逻辑运算非指令NOT"><a href="#逻辑运算非指令NOT" class="headerlink" title="逻辑运算非指令NOT"></a>逻辑运算非指令NOT</h4><p>从低位遍历到高位（二进制），求反(1变0,0变1)。</p>
<h5 id="基本语法-28"><a href="#基本语法-28" class="headerlink" title="基本语法"></a>基本语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">not reg&#x2F;mem</span><br></pre></td></tr></table></figure>

<h5 id="示例-24"><a href="#示例-24" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, 45h</span><br><span class="line">not al					;al&#x3D;bah</span><br></pre></td></tr></table></figure>



<h4 id="逻辑运算与测试指令TEST"><a href="#逻辑运算与测试指令TEST" class="headerlink" title="逻辑运算与测试指令TEST"></a>逻辑运算与测试指令TEST</h4><p>与and相同，但是只会改变状态寄存器，而其余不变。这样子就可以方便后面的跳转指令，与cmp指令差不多。</p>
<h5 id="基本语法-29"><a href="#基本语法-29" class="headerlink" title="基本语法"></a>基本语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test reg, imm&#x2F;reg&#x2F;mem	;dest &amp; src</span><br><span class="line">test mem, imm&#x2F;reg		;dest &amp; src</span><br></pre></td></tr></table></figure>

<h5 id="示例-25"><a href="#示例-25" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, 45h</span><br><span class="line">test al, 01h			;al&#x3D;45h,zf&#x3D;0</span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="移位指令"><a href="#移位指令" class="headerlink" title="移位指令"></a>移位指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shl reg&#x2F;mem, 1&#x2F;cl	;逻辑左移：1位或则cl位,最低位补0，最高位进入cf</span><br><span class="line">shr reg&#x2F;mem, 1&#x2F;cl	;逻辑右移：1位或则cl位,最高位补0，最低位进入cf </span><br><span class="line">sal reg&#x2F;mem, 1&#x2F;cl	;算术左移：1位或则cl位,最低位补0，最高位进入cf（同shl）</span><br><span class="line">sar reg&#x2F;mem, 1&#x2F;cl	;算术右移：1位或则cl位,最高位保持不变，最低位进入cf</span><br></pre></td></tr></table></figure>



<h3 id="循环移位指令"><a href="#循环移位指令" class="headerlink" title="循环移位指令"></a>循环移位指令</h3><p>数字从一端出来之后就补到另外一端。例如左移的时候最高位就补到最低位。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rol reg&#x2F;mem, 1&#x2F;cl	;不带进位的循环左移</span><br><span class="line">ror reg&#x2F;mem, 1&#x2F;cl	;不带进位的循环右移</span><br><span class="line">rcl reg&#x2F;mem, 1&#x2F;cl	;带进位的循环左移</span><br><span class="line">rcr reg&#x2F;mem, 1&#x2F;cl	;带进位的循环右移</span><br></pre></td></tr></table></figure>

<p>带进位的意思就是循环的位数加一个CF。例如左移时，最高位进入CF，CF进入最低位，其余位数左移。</p>
<h2 id="控制转移类指令"><a href="#控制转移类指令" class="headerlink" title="控制转移类指令"></a>控制转移类指令</h2><h3 id="无条件转移指令"><a href="#无条件转移指令" class="headerlink" title="无条件转移指令"></a>无条件转移指令</h3><p>jmp指令可以直接跳转到一个新的地方，但是请注意，跳转的地方与jmp指令的位置中间的代码或则数据<strong>不应该超过1MB</strong>。</p>
<ol>
<li>段内转移（短转移(8位地址)/近转移(16位地址)）：如果在当前代码段64KB范围内进行转移，即短转移</li>
<li>段间转移（远转移(32位地址)）：否则即为段间转移。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">;短转移</span><br><span class="line">	jmp label		;ip&lt;-ip+偏移量</span><br><span class="line">	jmp r16&#x2F;m16</span><br><span class="line">	...</span><br><span class="line">label:				;第一条指令将会跳到这里继续执行</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">;远转移</span><br><span class="line">	jmp far ptr label	;ip&lt;-label的偏移地址，cs&lt;-label所在的段地址（会自动查找）。这样子就直接跳到了label所在的位置。（不知道cs是什么的，去看笔记一）</span><br><span class="line">	jmp far ptr mem		;ip&lt;-[mem],cs&lt;-[mem+2],mem所指向的16位数赋值给ip，下一个16位数赋值给cs</span><br><span class="line">	</span><br><span class="line">	mov word ptr[bx], 0</span><br><span class="line">	mov word ptr[bx+2], 1500h</span><br><span class="line">	jmp far ptr[bx]		;跳转到1500h: 0的位置，新的代码段起始位置是1500h，偏移量是0，也就是执行1500h所在位置的代码</span><br></pre></td></tr></table></figure>



<h3 id="条件转移指令"><a href="#条件转移指令" class="headerlink" title="条件转移指令"></a>条件转移指令</h3><p>还记得之前的两个指令吗？一个cmp一个test。这两个指令配合条件条件转移指令就显得非常有用了。</p>
<table>
<thead>
<tr>
<th align="center">助记符</th>
<th align="center">标志位</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">JZ/JE</td>
<td align="center">ZF=1</td>
<td align="center">等于0(and)/相等(cmp)跳转</td>
</tr>
<tr>
<td align="center">JNZ/JNE</td>
<td align="center">ZF=0</td>
<td align="center">不等于0/不相等跳转</td>
</tr>
<tr>
<td align="center">JS</td>
<td align="center">SF=1</td>
<td align="center">符号为负跳转</td>
</tr>
<tr>
<td align="center">JNS</td>
<td align="center">SF=0</td>
<td align="center">符号为正跳转</td>
</tr>
<tr>
<td align="center">JP/JPE</td>
<td align="center">PF=1</td>
<td align="center">“1”的个数为偶数跳转</td>
</tr>
<tr>
<td align="center">JNP/JPO</td>
<td align="center">PF=0</td>
<td align="center">“1”的个数为奇数跳转</td>
</tr>
<tr>
<td align="center">JO</td>
<td align="center">OF=1</td>
<td align="center">溢出跳转</td>
</tr>
<tr>
<td align="center">JNO</td>
<td align="center">OF=0</td>
<td align="center">无溢出跳转</td>
</tr>
<tr>
<td align="center">JC/JB/JANE</td>
<td align="center">CF=1</td>
<td align="center">进位/低于/不高于等于跳转</td>
</tr>
<tr>
<td align="center">JNC/JNB/JAE</td>
<td align="center">CF=0</td>
<td align="center">无进位/不低于/高于等于跳转</td>
</tr>
<tr>
<td align="center">JBE/JNA</td>
<td align="center">CF=1 或则 ZF=1</td>
<td align="center">低于等于/不高于跳转</td>
</tr>
<tr>
<td align="center">JNBE/JA</td>
<td align="center">CF=0 并且 ZF=0</td>
<td align="center">不低于等于/高于跳转</td>
</tr>
<tr>
<td align="center">JL/JNGE</td>
<td align="center">SF≠OF</td>
<td align="center">小于/不大于等于跳转</td>
</tr>
<tr>
<td align="center">JNL/JGE</td>
<td align="center">SF=OF</td>
<td align="center">不小于/大于等于跳转</td>
</tr>
<tr>
<td align="center">JLE/JNG</td>
<td align="center">SF≠OF 或则 ZF=1</td>
<td align="center">小于等于/不大于跳转</td>
</tr>
<tr>
<td align="center">JNLE/JG</td>
<td align="center">SF=OF 或则 ZF=0</td>
<td align="center">不小于等于/大于跳转</td>
</tr>
</tbody></table>
<p>上述指令非常难记，整整16条指令，还有些有多个助记符。所以可以大概遵循一下以下的规律：</p>
<ol>
<li>所有指令开头都是 <strong>J</strong>，高于是 <strong>A</strong>，低于是 <strong>B</strong>，等于是 <strong>E</strong>，小于是 <strong>L</strong>，大于是 <strong>G</strong>，非是 <strong>N</strong>， 零是 <strong>Z</strong>，负数是 <strong>S</strong>，<em>（ 溢出是 <strong>O</strong>， 1的个数是 <strong>P</strong>）</em>。</li>
<li>对于<strong>JNBE</strong> 和 <strong>JA</strong> 这种相同意思的指令，尽量用简洁的描述，能够说<strong>高于</strong>，为什么要说<strong>不低于等于</strong>。</li>
<li>高于低于是对于<strong>无符号数</strong>，小于大于是对于<strong>有符号数</strong>。</li>
<li>指令基本是 **J + (N) + 相对大小 + (E)**。</li>
<li>可以只记住判断大小的，没必要记住什么溢出之类的。重点记住：<strong>JZ、JA、JAE、JB、JBE、JG、JGE、JL、JLE</strong>（基本都是两两一组非常好记）。这9个指令已经可以非常好的完成高级语言if功能了。</li>
</ol>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">;一个分支结构的例子</span><br><span class="line">	mov al, 09h</span><br><span class="line">	mov bl, 10h</span><br><span class="line">	cmp al, bl</span><br><span class="line">	jz equal</span><br><span class="line">notEqual:				;不相等</span><br><span class="line">	...</span><br><span class="line">	jmp continue</span><br><span class="line">equal:					;相等</span><br><span class="line">	...</span><br><span class="line">continue:				;继续</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">;求绝对值</span><br><span class="line">	mov ax, xxxxh		;1个数</span><br><span class="line">	sub ax, yyyyh		;另一个数</span><br><span class="line">	jns nonneg</span><br><span class="line">	neg ax				;求补</span><br><span class="line">nonneg:					;继续</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>



<h3 id="循环指令"><a href="#循环指令" class="headerlink" title="循环指令"></a>循环指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">;循环8次</span><br><span class="line">	mov cx, 8h</span><br><span class="line">label:</span><br><span class="line">	...</span><br><span class="line">	loop label</span><br></pre></td></tr></table></figure>

<p>loop指令没什么好讲的了，基本就是套公式，就是这样子一个架构。至于break、continue的功能，完全可以使用前面的转移指令来完成。</p>
<ol>
<li><p>cx的初值不能赋值0，否则cx先减去1之后，cx就变成了ffffh，然后在判断cx是否等于0，就不能直接退出了。</p>
</li>
<li><p>cx是程序的循环次数，不能改成别的。</p>
</li>
<li><p>loop指令等效于以下两条指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">	mov cx, 8h</span><br><span class="line">label:</span><br><span class="line">	...</span><br><span class="line">    dec cx</span><br><span class="line">    jnz label	;如果用这种方式来实现循环，那么就可以不用cx来作为循环变量了，当然不推荐这种写法。因为不要乱用寄存器，汇编语言的寄存器得精打细算。</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="子程序指令"><a href="#子程序指令" class="headerlink" title="子程序指令"></a>子程序指令</h3><p>子程序，就类似于高级语言的函数一样。一个函数就应该分为两部分指令：调用、返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">;子程序调用</span><br><span class="line">call label				;直接转移到label的位置</span><br><span class="line">call r16&#x2F;m16			;转移到r16所指向的位置</span><br><span class="line">call far ptr label		;远转移，不懂得去看jmp指令</span><br><span class="line">call far ptr mem</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;返回</span><br><span class="line">ret						;返回</span><br><span class="line">ret i16					;有参数返回,ip&lt;-ss:[sp], sp&lt;-sp+2, sp&lt;-sp+i16</span><br></pre></td></tr></table></figure>

<p>这部分，很可能就会问call与jmp有什么区别呢？</p>
<p>那首先就要搞懂他的工作原理。在讲之前要回忆一下两个指令push和pop，也就是栈操作指令。以及一个堆栈段SS寄存器，堆栈寻址寄存器SP。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">	call function</span><br><span class="line">	...</span><br><span class="line">	(退出)</span><br><span class="line">	;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">function:</span><br><span class="line">	...</span><br><span class="line">	ret</span><br><span class="line">	;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">function2:</span><br><span class="line">	...</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>

<p>这就是一个完整的子程序声明以及调用的过程了。当然你也可以根据你的喜欢调整子程序的位置，放到前面，插入中间都是可以。放到所有代码的后面只是推荐写法。</p>
<p>在call的时候就会将当前的ip寄存器压入栈顶，在ret的时候，同理也就会把原来的地址读取回来，放入ip当中（这里只是举例了段内转移，如果是段间转移还要保存cs）。</p>
<p>这里也就引入了一个问题，那就是<strong>退出子程序的时候堆栈一定要push干净！！！</strong>如果你没有push干净，那么ret的时候就会返回到你栈顶的元素所指向的地址位置，那就没有人知道回到哪里去了。</p>
<p>当然如果你有其他的作用，比如不按照规范书写程序，妄图挑战语法的极限，那也可以push一个合法的地址，然后ret到那个位置继续执行程序。</p>
<h3 id="中断指令"><a href="#中断指令" class="headerlink" title="中断指令"></a>中断指令</h3><h4 id="中断的类型"><a href="#中断的类型" class="headerlink" title="中断的类型"></a>中断的类型</h4><ol>
<li><p><strong>外部中断</strong>：来自CPU之外，例如：CPU想要打印一个东西，打印机这时候在忙，于是不能打印。CPU不可能一直等着打印机，用户还会继续其他的操作。这时候打印机打印好了，对CPU发起一个中断，告诉CPU，我现在闲下来了，可以打印了。这时候CPU看情况是否中断当前的程序，先去完成打印的事情。</p>
<ol>
<li>可屏蔽中断：也就是标志符IF=0，意思就是CPU可以屏蔽外部中断。比如：还是上述的打印机，但是打印机发起中断的时候你的电脑蓝屏了，这时候CPU正在执行电脑的自检程序，明显电脑我自己都崩溃了，还打印什么东西，这时候就可以屏蔽这个打印机的中断信号，直接不理打印机，继续自检。<ol>
<li>关中断指令CLI：使IF=0</li>
<li>开中断指令STI：使IF=1</li>
</ol>
</li>
<li>非屏蔽中断：也就是标志符IF=0，意思就是CPU不可以屏蔽外部中断，外部中断来的时候，先执行处理中断信号的程序，再回来。</li>
</ol>
</li>
<li><p><strong>内部中断</strong>：来自CPU内部的中断信号。也被叫做异常。（关于向量号是什么，后续会解释）</p>
<ol>
<li><p>除法错中断：除数为0，还有之前讲的商太大了的情况，就会产生一个个除法错误。它的向量号是0。</p>
</li>
<li><p>指令中断：指令<strong>int n</strong>，自己主动中断程序，产生一个向量号是n的中断。</p>
</li>
<li><p>溢出中断：执行溢出中断指令INTO时，将会判断OF，如果OF为1，则产生一个溢出中断，它的向量号为4</p>
</li>
<li><p>单步中断：如果标志符TF=1，则表示程序当前在单步调试，每执行一条指令就中断一次（常用于DOSBOX单步调试代码之类的地方）。</p>
</li>
</ol>
</li>
</ol>
<h4 id="中断的过程"><a href="#中断的过程" class="headerlink" title="中断的过程"></a>中断的过程</h4><p>在C语言里，经常会犯如下错误</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a);		<span class="comment">//读取一个16位整数（int）放入主存地址为0的地方</span></span><br></pre></td></tr></table></figure>

<p>这时候就会提示你段错误。</p>
<p><img src="%E6%AE%B5%E9%94%99%E8%AF%AF.png"></p>
<p>你的老师也会告诉你因为低地址被操作系统用了，你不能用。</p>
<p>而我们现在就可以了解低地址，操作系统究竟是怎么用的。</p>
<p>首先中断会有一个向量表，大小为1KB，存在<strong>主存的最低地址区域</strong>。也就是000H——3FFH。从0开始，每4个字节对应一个中断，总计有256个中断向量。前5个汇编语言给出了定义，所以请不要乱用。</p>
<ol>
<li>其中4个在内部中断都有讲，比如断点的中断就应该指向编译器或则IDE之类的程序。</li>
<li><strong>NMI中断</strong>  (Non Maskable Interrupt) <strong>：不可屏蔽中断</strong>，也就是说不管你的IF是几，这个中断不能屏蔽。类似于系统崩溃之类的严重错误就可以使用该中断信号。</li>
</ol>
<p><img src="%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8.png"></p>
<p>如上图所示，1个字节8位，2个字节16位，于是32个字节，刚好保存下来cs与ip。</p>
<p>所以调用中断程序的步骤如下：</p>
<ol>
<li><strong>将标志寄存器存入栈保存</strong></li>
<li><strong>禁止新的可屏蔽中断和单步中断：IF=TF=0</strong></li>
<li><strong>在哪里中断的，将这个断点地址保存入堆栈</strong></li>
<li><strong>读取中断服务程序的起始地址。</strong></li>
</ol>
<p>恢复中断的过程如下：</p>
<ol>
<li><strong>取出断点地址，放到ip与cs中</strong></li>
<li><strong>取出标志寄存器</strong></li>
</ol>
<p>观察上述过程很容易发现几个问题：</p>
<ol>
<li>寄存器值是会改变的，因为中断操作没有保存寄存器的值，所以如果进行中断，需要保存寄存器的值，请手动入栈保存。</li>
<li>如果自己书写中断程序，应该保证栈要清空，这点与子程序是一样的。如果栈没有清空就会导致，跳转到莫名其妙的地方。当然你也可以尝试挑战语法极限。</li>
<li>中断信号只有256个，如果中断程序超过256个怎么办？可以写一个中断调用程序，然后传递参数。比如用满了255号中断，在执行的时候看一下ax寄存器，或则看一下某个地址存储的值。然后一看是1，就调用A中断程序，一看是2就调用B中断程序。理论上可中断掉用程序套用中断调用程序，无限套娃。</li>
<li>传递参数，例如dos系统非常常用的中断21h，就是以ax来作为参数的。寄存器、主存都可以用来传递参数。但是更建议寄存器，主存存在安全问题，而且有些时候可能会拒绝访问。</li>
</ol>
<h4 id="中断操作指令"><a href="#中断操作指令" class="headerlink" title="中断操作指令"></a>中断操作指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int 21h			;产生向量21h的中断信号</span><br><span class="line">iret			;中断返回（如果你写的是一个中断处理程序的话）</span><br><span class="line">into			;溢出中断，如果OF&#x3D;1，则产生中断，反之则不产生。</span><br></pre></td></tr></table></figure>



<h2 id="串操作类指令"><a href="#串操作类指令" class="headerlink" title="串操作类指令"></a>串操作类指令</h2><h3 id="串传送指令"><a href="#串传送指令" class="headerlink" title="串传送指令"></a>串传送指令</h3><ol>
<li><p>获取偏移地址指令OFFSET</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">;如何声明一个段我们还没有学，假设下面代码是合法的，这俩玩意儿可以就这样放在一起。</span><br><span class="line">;数据段(ds)</span><br><span class="line">string db &quot;hello world!&quot;, &#39;$&#39;</span><br><span class="line">;代码段(cs)</span><br><span class="line">mov ax, offset string</span><br></pre></td></tr></table></figure>

<p>上述代码ax存放的就是string有关于ds的偏移地址是多少。</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">;如何声明一个段我们还没有学，假设下面代码是合法的，这俩玩意儿可以就这样放在一起。</span><br><span class="line">;数据段(ds)</span><br><span class="line">string db &quot;hello world!&quot;, &#39;$&#39;</span><br><span class="line">;代码段(cs)</span><br><span class="line">mov ax, seg string</span><br></pre></td></tr></table></figure>

<p>上述代码ax存放的就是string所在数据段ds地址是多少。</p>
</li>
<li><p>串传送指令MOVS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movsb		;字节传送：es:[di]&lt;-ds:[si],si&lt;-si+1,di&lt;-di+1</span><br><span class="line">movsw		;字传送：es:[di]&lt;-ds:[si],si&lt;-si+2,di&lt;-di+2</span><br></pre></td></tr></table></figure>

<p><strong>切记：这里的3——5三种指令中SI与DI究竟是加1、2还是减去，取决于方向标志符DF（详见笔记一）。</strong></p>
</li>
<li><p>串储存指令STOS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stosb		;字节储存：es:[di]&lt;-al,di&lt;-di+1</span><br><span class="line">stosw		;字储存：es:[di]&lt;-ax,di&lt;-di+2</span><br></pre></td></tr></table></figure>
</li>
<li><p>串读取指令LODS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lodsb		;字节读取：al&lt;-ds:[si],si&lt;-si+1</span><br><span class="line">lodsw		;字读取：ax&lt;-ds:[si],si&lt;-si+2</span><br></pre></td></tr></table></figure>


</li>
<li><p>重复前缀指令REP</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rep xxx		;执行上述3——5三种指令前，每次执行cx减去一，直到cx等于0停止</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="串检测指令"><a href="#串检测指令" class="headerlink" title="串检测指令"></a>串检测指令</h3><p>下面1、2两条比较指令都是是否相同都取决于ZF。ZF=1，即相等。</p>
<ol>
<li><p>串比较指令CMPS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmpsb		;字节比较：es:[di]与ds:[si],si&lt;-si+1,di&lt;-di+1</span><br><span class="line">cmpsw		;字比较：es:[di]与ds:[si],si&lt;-si+2,di&lt;-di+2</span><br></pre></td></tr></table></figure>

<p>加减同样取决于DF。</p>
</li>
<li><p>串扫描指令SCAS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scasb		;字节比较：es:[di]与al,di&lt;-di+1</span><br><span class="line">scasw		;字比较：es:[di]与ax,di&lt;-di+2</span><br></pre></td></tr></table></figure>


</li>
<li><p>重复前缀指令REPE/REPZ</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">repe</span><br><span class="line">repz</span><br></pre></td></tr></table></figure>

<p>这里N、Z、E有没有有没有很熟悉。像极了我们的条件转移。</p>
<p>可以加在1的两种指令上，将会重复执行CX次。如果ZF=0（不相等）则退出。</p>
<p>可以用于比较两个字符串是否相等</p>
</li>
<li><p>重复前缀指令REPNE/PRENZ</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">repne</span><br><span class="line">repnz</span><br></pre></td></tr></table></figure>

<p>既然加了N就不用讲了吧，如果相等就退出，重复CX次。</p>
</li>
</ol>
<h2 id="处理机控制类指令"><a href="#处理机控制类指令" class="headerlink" title="处理机控制类指令"></a>处理机控制类指令</h2><h4 id="空操作指令NOP"><a href="#空操作指令NOP" class="headerlink" title="空操作指令NOP"></a>空操作指令NOP</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nop</span><br></pre></td></tr></table></figure>

<p>什么也不做，占用1条指令的存储单元。CPU会空耗一条指令的执行时间。假如add指令需要25ns，那nop就在这25ns里啥也不干。就等于电信号跑了一段空回路，没有任何操作的电路。</p>
<p>作用：</p>
<ol>
<li>没想好写什么</li>
<li>延时</li>
</ol>
<h4 id="段超越前缀指令SEG"><a href="#段超越前缀指令SEG" class="headerlink" title="段超越前缀指令SEG"></a>段超越前缀指令SEG</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cs:</span><br><span class="line">ss:</span><br><span class="line">ds:</span><br><span class="line">es:</span><br></pre></td></tr></table></figure>

<p>在允许段超越的（见笔记一）的操作数前加上段超越前缀指令，将不采用默认的段寄存器寻址，而采用超越段的地址寻址。（建议最好都加上，也可以提醒自己。这个数据是来自哪个段的）</p>
<h4 id="封锁前缀指令LOCK"><a href="#封锁前缀指令LOCK" class="headerlink" title="封锁前缀指令LOCK"></a>封锁前缀指令LOCK</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock</span><br></pre></td></tr></table></figure>

<p>这是一个指令前缀，可以加在指令的前面，可以如下使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock add ax, bx</span><br></pre></td></tr></table></figure>

<p>可以封锁CPU的总线，避免要运算的值，在运算期间遭到修改。常用于多个CPU协同合作的时候。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hlt</span><br></pre></td></tr></table></figure>

<p>一般不建议使用，该指令会让CPU停下当前的所有操作，直接暂停，也就是“死机”。直到CPU复位，或则接收到外部中断信号。</p>
<p>应用于子程序等待中断的时候，例如打印机处在不工作的模式就使用hlt指令，暂停工作。然后等到来自外部的要打印的中断信号，继续工作。然后再待机（“死机”）。</p>
<h4 id="交权指令ESC"><a href="#交权指令ESC" class="headerlink" title="交权指令ESC"></a>交权指令ESC</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">esc 6位立即数(i6), reg&#x2F;mem		;把浮点指令交给浮点处理器</span><br></pre></td></tr></table></figure>

<p>该指令是后续引入了8087浮点数运算协处理器之后引入的。因为你会发现8086处理器本身支持了正数负数，但是唯独没有支持小数。当然本身二进制数是没有意义的，你也可以自己设计小数的加减乘除。但是为了一条指令就能够实现，于是引入了8087。遇到处理浮点数的指令的时候，就会把这个指令发送给8087，让他处理完了再返回值。这个过程就是交权。</p>
<p>第一个6位立即数是操作码，也就是该怎么算，加减乘除还是什么？本质上add指令也是一串操作码，但是他有一个add的助记符，通过编译器再翻译成二进制数，但是8087就没有这个助记符，需要查阅文档。</p>
<p>（当然现在的CPU早就已经可以完成浮点运算，并且还是64位的寄存器，有些乃至128位的寄存器，已经远非8086这个16位寄存器的CPU所能够比的了。但是原理上是互通的。）</p>
<h4 id="等待指令WAIT"><a href="#等待指令WAIT" class="headerlink" title="等待指令WAIT"></a>等待指令WAIT</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wait</span><br></pre></td></tr></table></figure>

<p>wait指令在8086的测试输入引脚（CPU上密密麻麻的引脚中的一个）为高电平时保持不动，直到该引脚为低电平的时候才会继续执行。（如果你是学电科的，也可以通过专业设备来输入一个低电平测试）</p>
<p>该指令存在的意义是8087进行浮点数运算的速度远远慢慢8086处理整数的速度，为了避免两个处理器出现异步，引入了wait指令来使得8086等待保持同步。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%80%83%E8%AF%95%E7%AC%94%E8%AE%B0/" rel="tag"># 考试笔记</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/05/20/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%882%EF%BC%89/" rel="prev" title="汇编语言（一）">
      <i class="fa fa-chevron-left"></i> 汇编语言（一）
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/07/09/%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%8D%95%E8%AF%8D%E7%BB%9F%E8%AE%A1/" rel="next" title="文本文件单词统计">
      文本文件单词统计 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E7%B1%BB%E6%8C%87%E4%BB%A4"><span class="nav-text">数据传送类指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><span class="nav-text">通用数据传送指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4MOV"><span class="nav-text">传送指令MOV</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%88%E6%B3%95%E6%93%8D%E4%BD%9C"><span class="nav-text">合法操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E6%8C%87%E4%BB%A4XCHG"><span class="nav-text">交换指令XCHG</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-1"><span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8D%A2%E7%A0%81%E6%8C%87%E4%BB%A4XLAT"><span class="nav-text">换码指令XLAT</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-2"><span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="nav-text">示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E6%A0%88%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4"><span class="nav-text">堆栈操作指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A5%E6%A0%88%E6%8C%87%E4%BB%A4PUSH"><span class="nav-text">入栈指令PUSH</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-3"><span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BA%E6%A0%88%E6%8C%87%E4%BB%A4POP"><span class="nav-text">出栈指令POP</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-4"><span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-4"><span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-text">堆栈的应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%BF%97%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><span class="nav-text">标志传送指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8%E4%BC%A0%E9%80%81"><span class="nav-text">标志寄存器传送</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8%E4%BC%A0%E5%85%A5AH%E6%8C%87%E4%BB%A4LAHF"><span class="nav-text">标志寄存器传入AH指令LAHF</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-5"><span class="nav-text">基本语法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AH%E4%BC%A0%E5%85%A5%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8%E6%8C%87%E4%BB%A4SAHF"><span class="nav-text">AH传入标志寄存器指令SAHF</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-6"><span class="nav-text">基本语法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8%E5%85%A5%E6%A0%88%E6%8C%87%E4%BB%A4PUSHF"><span class="nav-text">标志寄存器入栈指令PUSHF</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-7"><span class="nav-text">基本语法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8%E5%87%BA%E6%A0%88%E6%8C%87%E4%BB%A4POPF"><span class="nav-text">标志寄存器出栈指令POPF</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E5%BF%97%E4%BD%8D%E6%93%8D%E4%BD%9C"><span class="nav-text">标志位操作</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-8"><span class="nav-text">基本语法</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><span class="nav-text">地址传送指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E6%95%88%E5%9C%B0%E5%9D%80%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4LEA"><span class="nav-text">有效地址传送指令LEA</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-9"><span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-5"><span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4LES%E3%80%81LDS"><span class="nav-text">指针传送指令LES、LDS</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-10"><span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-6"><span class="nav-text">示例</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%B1%BB%E6%8C%87%E4%BB%A4"><span class="nav-text">算数运算类指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E6%B3%95%E6%8C%87%E4%BB%A4"><span class="nav-text">加法指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E6%B3%95%E6%8C%87%E4%BB%A4ADD"><span class="nav-text">加法指令ADD</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-11"><span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-7"><span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%A6%E8%BF%9B%E4%BD%8D%E5%8A%A0%E6%B3%95%E6%8C%87%E4%BB%A4ADC"><span class="nav-text">带进位加法指令ADC</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-12"><span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-8"><span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A2%9E%E9%87%8F%E6%8C%87%E4%BB%A4INC"><span class="nav-text">增量指令INC</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-13"><span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-9"><span class="nav-text">示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%8F%E6%B3%95%E6%8C%87%E4%BB%A4"><span class="nav-text">减法指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%8F%E6%B3%95%E6%8C%87%E4%BB%A4SUB"><span class="nav-text">减法指令SUB</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-14"><span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-10"><span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%A6%E9%94%99%E4%BD%8D%E5%87%8F%E6%B3%95%E6%8C%87%E4%BB%A4SBB"><span class="nav-text">带错位减法指令SBB</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-15"><span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-11"><span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%8F%E9%87%8F%E6%8C%87%E4%BB%A4DEC"><span class="nav-text">减量指令DEC</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-16"><span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-12"><span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%82%E8%A1%A5%E6%8C%87%E4%BB%A4NEG"><span class="nav-text">求补指令NEG</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-17"><span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-13"><span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E6%8C%87%E4%BB%A4CMP"><span class="nav-text">比较指令CMP</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-18"><span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-14"><span class="nav-text">示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%98%E6%B3%95%E6%8C%87%E4%BB%A4"><span class="nav-text">乘法指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E4%B9%98%E6%B3%95%E6%8C%87%E4%BB%A4MUL"><span class="nav-text">无符号数乘法指令MUL</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-19"><span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-15"><span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E4%B9%98%E6%B3%95%E6%8C%87%E4%BB%A4IMUL"><span class="nav-text">有符号数乘法指令IMUL</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-20"><span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-16"><span class="nav-text">示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%A4%E6%B3%95%E6%8C%87%E4%BB%A4"><span class="nav-text">除法指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E9%99%A4%E6%B3%95%E6%8C%87%E4%BB%A4DIV"><span class="nav-text">无符号数除法指令DIV</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-21"><span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-17"><span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E9%99%A4%E6%B3%95%E6%8C%87%E4%BB%A4IDIV"><span class="nav-text">有符号数除法指令IDIV</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-22"><span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-18"><span class="nav-text">示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E6%89%A9%E5%B1%95%E6%8C%87%E4%BB%A4"><span class="nav-text">符号扩展指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%81%E8%BF%9B%E5%88%B6%E8%B0%83%E6%95%B4%E6%8C%87%E4%BB%A4"><span class="nav-text">十进制调整指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9BCD%E7%A0%81%E8%B0%83%E6%95%B4%E6%8C%87%E4%BB%A4"><span class="nav-text">压缩BCD码调整指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-23"><span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-19"><span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E5%8E%8B%E7%BC%A9BCD%E7%A0%81%E8%B0%83%E6%95%B4%E6%8C%87%E4%BB%A4"><span class="nav-text">非压缩BCD码调整指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-24"><span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-20"><span class="nav-text">示例</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%B1%BB%E6%8C%87%E4%BB%A4"><span class="nav-text">位操作类指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4"><span class="nav-text">逻辑运算指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E4%B8%8E%E6%8C%87%E4%BB%A4AND"><span class="nav-text">逻辑运算与指令AND</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-25"><span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-21"><span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E6%88%96%E6%8C%87%E4%BB%A4OR"><span class="nav-text">逻辑运算或指令OR</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-26"><span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-22"><span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E5%BC%82%E6%88%96%E6%8C%87%E4%BB%A4XOR"><span class="nav-text">逻辑运算异或指令XOR</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-27"><span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-23"><span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E9%9D%9E%E6%8C%87%E4%BB%A4NOT"><span class="nav-text">逻辑运算非指令NOT</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-28"><span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-24"><span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E4%B8%8E%E6%B5%8B%E8%AF%95%E6%8C%87%E4%BB%A4TEST"><span class="nav-text">逻辑运算与测试指令TEST</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-29"><span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-25"><span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-text"></span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E4%BD%8D%E6%8C%87%E4%BB%A4"><span class="nav-text">移位指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E7%A7%BB%E4%BD%8D%E6%8C%87%E4%BB%A4"><span class="nav-text">循环移位指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E8%BD%AC%E7%A7%BB%E7%B1%BB%E6%8C%87%E4%BB%A4"><span class="nav-text">控制转移类指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4"><span class="nav-text">无条件转移指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4"><span class="nav-text">条件转移指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E6%8C%87%E4%BB%A4"><span class="nav-text">循环指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E7%A8%8B%E5%BA%8F%E6%8C%87%E4%BB%A4"><span class="nav-text">子程序指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E6%8C%87%E4%BB%A4"><span class="nav-text">中断指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-text">中断的类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-text">中断的过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4"><span class="nav-text">中断操作指令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%B2%E6%93%8D%E4%BD%9C%E7%B1%BB%E6%8C%87%E4%BB%A4"><span class="nav-text">串操作类指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><span class="nav-text">串传送指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E6%A3%80%E6%B5%8B%E6%8C%87%E4%BB%A4"><span class="nav-text">串检测指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E6%8E%A7%E5%88%B6%E7%B1%BB%E6%8C%87%E4%BB%A4"><span class="nav-text">处理机控制类指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4NOP"><span class="nav-text">空操作指令NOP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AE%B5%E8%B6%85%E8%B6%8A%E5%89%8D%E7%BC%80%E6%8C%87%E4%BB%A4SEG"><span class="nav-text">段超越前缀指令SEG</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%81%E9%94%81%E5%89%8D%E7%BC%80%E6%8C%87%E4%BB%A4LOCK"><span class="nav-text">封锁前缀指令LOCK</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%A4%E6%9D%83%E6%8C%87%E4%BB%A4ESC"><span class="nav-text">交权指令ESC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%E6%8C%87%E4%BB%A4WAIT"><span class="nav-text">等待指令WAIT</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="康慧春"
      src="/images/aaa.gif">
  <p class="site-author-name" itemprop="name">康慧春</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/2738132159" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;2738132159" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5880774808" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5880774808" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">康慧春</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
-->

<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_uv">
    本站总访客数:<span id="busuanzi_value_site_uv"></span>&nbsp;&nbsp;| 
  </span>
  <span id="busuanzi_container_site_pv">
      &nbsp;本站总访问量<span id="busuanzi_value_site_pv"></span>次
  </span>
  </div>
  </div>

  <script>
      var now = new Date(); 
      function createtime() { 
          var grt= new Date("03/12/2019 12:00:00");//此处修改你的建站时间或者网站上线时间 
          now.setTime(now.getTime()+250); 
          days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
          hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
          if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
          mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
          seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
          snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
          document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
          document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
      } 
  setInterval("createtime()",250);
  </script>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three.min.js"></script>
    <script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@latest/canvas_lines.min.js"></script>







  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'FqVYHd2w8d1GR2oiPezc90bN-gzGzoHsz',
      appKey     : 'v5NPCMaETpbIGgAWtljExUU9',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
